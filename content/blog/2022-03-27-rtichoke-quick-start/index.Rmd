---
title: Box-Cox transformation from Feature Engineering by Max Kuhn and Kjell Johnson
author: ''
date: '2022-05-19'
slug: []
categories: [replications, roc]
tags: []
output: 
  html_document: 
    keep_md: yes
---

## Welcome to rtichoke blog!

This blog will be dedicated to the {rtichoke} package, which means that it will contain posts that are related to performance metrics and the possible related usability of {rtichoke}.

## Replications

In order to make the package easier to use I plan to reproduce other people's code with rtichoke, these kind of posts will be available under the category "replications".

My first choice is to replicate the first example from the book ["Feature Engineering and Selection: A Practical Approach for Predictive Models by Max Kuhn and Kjell Johnson"](http://www.feat.engineering/a-simple-example.html).

In this example you can see how Box-Cox transformation improves the discrimination capability of the logistic regression model without using any additional information.

## Original Code

The code is almost identical to the original code that can be found [on github](https://github.com/topepo/FES/blob/master/01_Introduction/1_01_A_Simple_Example.R).

### Preparing the Data

```{r message=FALSE, warning=FALSE}
library(caret)
library(tidymodels)
library(ggthemes)

data(segmentationData)

segmentationData <- 
  segmentationData %>% 
  dplyr::select(EqSphereAreaCh1, PerimCh1, Class, Case) %>% 
  setNames(c("PredictorA", "PredictorB", "Class", "Case")) %>% 
  mutate(Class = factor(ifelse(Class == "PS", "One", "Two")))

example_train <- 
  segmentationData %>% 
  dplyr::filter(Case == "Train") %>% 
  dplyr::select(-Case)

example_test  <- 
  segmentationData %>% 
  dplyr::filter(Case == "Test") %>% 
  dplyr::select(-Case)
```


### Training the Models

```{r}

example_ctrl <- 
  trainControl(method = "none",
               classProbs = TRUE,
               summaryFunction = twoClassSummary)

natural_terms <- train(Class ~ PredictorA + PredictorB,
                       data = example_train,
                       method = "glm",
                       metric = "ROC",
                       trControl = example_ctrl)

trans_terms <- train(Class ~ PredictorA + PredictorB,
                     data = example_train,
                     method = "glm",
                     preProc = "BoxCox",
                     metric = "ROC",
                     trControl = example_ctrl)

```



### Creating ROC Curve with {yardstick}


```{r echo=FALSE, message=FALSE, warning=FALSE}


natural_dat <-
  example_test %>% 
  mutate(prob = predict(natural_terms, example_test, type = "prob")[,1]) %>% 
  roc_curve(Class, prob) %>% 
  mutate(Format = "Natural Units")

trans_dat <-
  example_test %>% 
  mutate(prob = predict(trans_terms, example_test, type = "prob")[,1]) %>% 
  roc_curve(Class, prob) %>% 
  mutate(Format = "Inverse Units") 

both_dat <- 
  bind_rows(natural_dat, trans_dat) %>%
  mutate(Format = factor(Format, levels = c("Natural Units", "Inverse Units")))

trans_roc_plot <- 
  ggplot(both_dat) +
  geom_step(aes(x = 1 - specificity, y = sensitivity, color = Format)) + 
  coord_equal() + 
  xlab("False Positive Rate") + 
  ylab("True Positive Rate") + 
  theme_bw()+ 
  theme(legend.position = c(.8, .2)) + 
  scale_colour_manual(values = c("Natural Units" = "grey", "Inverse Units" = "black")) + 
  geom_abline(intercept = 0, slope = 1, col = "grey", lty = 2)  +   
  theme(panel.background = element_rect(fill = '#fff7f5', color = '#fff7f5'),
        plot.background = element_rect(fill = "#fff7f5"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.background = element_blank(),
        legend.box.background = element_blank(),
        strip.background = element_blank())

trans_roc_plot

```
## rtichoke code

### Creating ROC Curve with {rtichoke}

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(rtichoke)

create_roc_curve(
  probs = list(
    "Natural Units" = predict(natural_terms, 
                            example_test, type = "prob")[,1],
    "Inverse Units" = predict(trans_terms, 
                            example_test, type = "prob")[,1]
  ),
  reals = list(example_test$Class == "One"),
  size = 500, 
  col_values = c("grey", "black")
) %>% 
plotly::layout(plot_bgcolor = "#fff7f5", 
               paper_bgcolor= "#fff7f5")

```

